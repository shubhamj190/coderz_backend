# apps/accounts/api/v1/auth/serializers.py
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework import serializers
from apps.accounts.models.user import UserDetails, User
from apps.accounts.models import Grade, Division
from django.db import transaction

class CustomTokenObtainPairSerializer(TokenObtainPairSerializer):
    def validate(self, attrs):
        data = super().validate(attrs)
        user = self.user
        data['user_id'] = user.UserId
        if hasattr(self.user, 'details') and self.user.details:
            data['role'] = self.user.details.UserType
        else:
            data['role'] = None
        return data
        return data
    
class GradeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Grade
        fields = '__all__'

class DivisionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Division
        fields = '__all__'

class TeacherCreateSerializer(serializers.ModelSerializer):
    # Fields for creating the related User record
    email = serializers.EmailField(write_only=True)
    password = serializers.CharField(
        write_only=True, style={'input_type': 'password'}
    )
    first_name = serializers.CharField(write_only=True)
    last_name = serializers.CharField(write_only=True)
    gender = serializers.ChoiceField(choices=UserDetails.GENDER_CHOICES, write_only=True)
    
    # Teacher-specific many-to-many fields (if these exist on UserDetails)
    assigned_grades = serializers.PrimaryKeyRelatedField(
        queryset=Grade.objects.all(), many=True, required=False
    )
    assigned_divisions = serializers.PrimaryKeyRelatedField(
        queryset=Division.objects.all(), many=True, required=False
    )
    
    class Meta:
        # We return the UserDetails instance as the created object.
        model = UserDetails
        fields = [
            "assigned_grades",
            "assigned_divisions",
            "email",
            "password",
            "first_name",
            "last_name",
            "gender"
        ]
    
    def create(self, validated_data):
        try:
            # Extract basic user fields.
            email = validated_data.pop("email")
            password = validated_data.pop("password")
            first_name = validated_data.pop("first_name")
            last_name = validated_data.pop("last_name")
            gender = validated_data.pop("gender")
            
            # Pop teacher-specific many-to-many fields.
            assigned_grades = validated_data.pop("assigned_grades", None)
            assigned_divisions = validated_data.pop("assigned_divisions", None)
            
            with transaction.atomic():
                # Create the user in the User table. Pass user_type as 'teacher' to the manager.
                user = User.objects.create_user(
                    UserName=None,  # auto-generated by the custom manager
                    Email=email,
                    password=password,
                    InstitutionId=1
                )
                
                # Create the corresponding UserDetails record.
                details = UserDetails.objects.create(
                    user=user,
                    FirstName=first_name,
                    LastName=last_name,
                    Gender=gender,
                    UserType='Teacher'
                    # Other fields can be populated as needed.
                )
                
                # If your UserDetails model includes many-to-many relationships, assign them.
                if assigned_grades is not None:
                    details.assigned_grades.set(assigned_grades)
                if assigned_divisions is not None:
                    details.assigned_divisions.set(assigned_divisions)
            
            return details
        except Exception as e:
            raise serializers.ValidationError({"error": str(e)})
    
class TeacherListSerializer(serializers.ModelSerializer):
    full_name = serializers.SerializerMethodField()
    UserName = serializers.CharField(source="user.UserName", read_only=True)
    email = serializers.CharField(source="user.Email", read_only=True)
    gender = serializers.CharField(source="user.gender", read_only=True)
    UserId = serializers.CharField(source="user.UserId", read_only=True)
    userType = serializers.CharField(source="UserType", read_only=True)
    IsActive = serializers.CharField(source="user.IsActive", read_only=True)

    class Meta:
        model = UserDetails
        fields = ['full_name', 'email', 'UserId', 'UserName', 'gender', 'userType','IsActive']

    def get_full_name(self, obj):
        first = obj.FirstName or ""
        last = obj.LastName or ""
        return f"{first} {last}".strip()
    
class TeacherDetailSerializer(serializers.ModelSerializer):
    # Fields from the related User model
    # first_name = serializers.CharField(source="user.FirstName", required=False)
    # last_name = serializers.CharField(source="user.LastName", required=False)
    email = serializers.CharField(source="user.Email", read_only=True)
    gender = serializers.CharField(source="user.gender", read_only=True)
    UserId = serializers.CharField(source="user.UserId", read_only=True)
    IsActive = serializers.CharField(source="user.IsActive", read_only=True)
    
    class Meta:
        model = UserDetails
        fields = [
            "UserId",               # Teacher's primary key (UserId from related user)
            "FirstName",            # Updatable user first name
            "LastName",        # Updatable user last name
            "email",           # Updatable user gender
            "gender",  # Updatable user phone number
            "IsActive",
            "assigned_grades",
            "assigned_divisions",
            # You can add other fields (like available_time_slots, is_active, etc.) as needed.
        ]
    
    def get_full_name(self, obj):
        first = obj.FirstName or ""
        last = obj.LastName or ""
        return f"{first} {last}".strip()

    def update(self, instance, validated_data):
        # Extract and update nested user data.
        user_data = validated_data.pop("user", {})
        user = instance.user
        for attr, value in user_data.items():
            if attr == "UserName":
                continue
            setattr(user, attr, value)
        user.save()
        import pdb; pdb.set_trace()
        # Extract many-to-many fields separately.
        assigned_grades = validated_data.pop("assigned_grades", None)
        assigned_divisions = validated_data.pop("assigned_divisions", None)
        
        # Update the remaining fields on UserDetails.
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        
        # Update many-to-many relationships if provided.
        if assigned_grades is not None:
            instance.assigned_grades.set(assigned_grades)
        if assigned_divisions is not None:
            instance.assigned_divisions.set(assigned_divisions)
        
        return instance
    
class StudentCreateSerializer(serializers.ModelSerializer):
    email = serializers.EmailField(write_only=True)
    password = serializers.CharField(write_only=True, style={'input_type': 'password'}, required=False)
    first_name = serializers.CharField(write_only=True)
    last_name = serializers.CharField(write_only=True)
    gender = serializers.ChoiceField(choices=UserDetails.GENDER_CHOICES, write_only=True)
    
    class Meta:
        model = UserDetails
        fields = [
            "date_of_birth",
            "grade",           # PK or instance of Grade
            "division",        # PK or instance of Division
            "roll_number",
            "parent_name",
            "parent_email",
            "parent_phone",
            "admission_number",
            "email",
            "password",
            "first_name",
            "last_name",
            "gender"
        ]
    
    def create(self, validated_data):
        email = validated_data.get("email")
        password = validated_data.get("password")
        first_name = validated_data.get("first_name")
        last_name = validated_data.get("last_name")
        gender = validated_data.get("gender")
        roll_number = validated_data.get("roll_number")
        grade = validated_data.get("grade")
        division = validated_data.get("division")
        date_of_birth = validated_data.get("date_of_birth")
        parent_name = validated_data.get("parent_name", "")
        parent_email = validated_data.get("parent_email", "")
        parent_phone = validated_data.get("parent_phone", "")
        admission_number = validated_data.get("admission_number")
        
        with transaction.atomic():
            # Create the User record with role 'student'
            user = User.objects.create_user(
                Email=email,
                password=password,
                role='student',
                FirstName=first_name,
                LastName=last_name,
                gender=gender,
                roll_number=roll_number,
                grade=grade,
                division=division
            )
            
            # Create the Student record linking to the user.
            student = UserDetails.objects.create(
                user=user,
                FirstName=first_name,
                LastName=last_name,
                date_of_birth=date_of_birth,
                grade=grade,
                division=division,
                roll_number=roll_number,
                parent_name=parent_name,
                parent_email=parent_email,
                parent_phone=parent_phone,
                admission_number=admission_number
            )
        return student
    
class StudentListSerializer(serializers.ModelSerializer):
    full_name = serializers.SerializerMethodField()
    UserName = serializers.CharField(source="user.UserName", read_only=True)
    email = serializers.CharField(source="user.Email", read_only=True)
    gender = serializers.CharField(source="user.gender", read_only=True)

    class Meta:
        model = UserDetails
        fields = ['full_name', 'email','id', 'UserName', 'gender', 'is_active','grade','division']

    def get_full_name(self, obj):
        # Combine first and last names; adjust as needed.
        first = obj.user.FirstName or ""
        last = obj.user.LastName or ""
        return f"{first} {last}".strip()

class StudentDetailSerializer(serializers.ModelSerializer):
    # Nested user fields (read-only username)
    FirstName = serializers.CharField(source="user.FirstName", required=False)
    LastName = serializers.CharField(source="user.LastName", required=False)
    gender = serializers.CharField(source="user.gender", required=False)
    Email = serializers.EmailField(source="user.Email", required=False)
    PhoneNumber = serializers.CharField(source="user.PhoneNumber", required=False)
    
    class Meta:
        model = UserDetails
        fields = [
            "id",                # Student's primary key
            "FirstName",         # Updatable user first name
            "LastName",          # Updatable user last name
            "gender",            # Updatable user gender
            "Email",             # Updatable user email
            "PhoneNumber",       # Updatable user phone number
            "date_of_birth",
            "grade",
            "division",
            "roll_number",
            "parent_name",
            "parent_email",
            "parent_phone",
            "admission_number",
            "is_active"          # Student's active status
        ]
    
    def update(self, instance, validated_data):
        # Extract nested user data if provided.
        user_data = validated_data.pop("user", {})
        user = instance.user
        for attr, value in user_data.items():
            # Skip updating the username even if provided.
            if attr == "UserName":
                continue
            setattr(user, attr, value)
        user.save()
        
        # Update Student-specific fields.
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        return instance

class StudentUpdateSerializer(serializers.ModelSerializer):
    # Nested user fields:
    UserName = serializers.CharField(source="user.UserName", read_only=True)
    FirstName = serializers.CharField(source="user.FirstName", required=False)
    LastName = serializers.CharField(source="user.LastName", required=False)
    gender = serializers.CharField(source="user.gender", required=False)
    Email = serializers.EmailField(source="user.Email", required=False)
    PhoneNumber = serializers.CharField(source="user.PhoneNumber", required=False)

    class Meta:
        model = UserDetails
        fields = [
            "UserName",         # read-only, coming from the related User model
            "FirstName",        # updatable user first name
            "LastName",         # updatable user last name
            "gender",           # updatable user gender
            "Email",            # updatable user email
            "PhoneNumber",      # updatable user phone number
            "date_of_birth",
            "grade",
            "division",
            "roll_number",
            "parent_name",
            "parent_email",
            "parent_phone",
            "admission_number",
            "is_active"         # student-specific active flag
        ]
    
    def update(self, instance, validated_data):
        # Extract user data from nested input, if provided.
        user_data = validated_data.pop("user", {})
        user = instance.user

        # Update user fields except for UserName.
        for attr, value in user_data.items():
            if attr == "UserName":
                continue
            setattr(user, attr, value)
        user.save()
        
        # Update remaining student fields.
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        return instance