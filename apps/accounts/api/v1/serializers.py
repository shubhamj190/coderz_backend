# apps/accounts/api/v1/auth/serializers.py
from django.forms import ValidationError
from rest_framework_simplejwt.serializers import TokenObtainPairSerializer
from rest_framework import serializers
from apps.accounts.models.user import UserDetails, User
from apps.accounts.models import Grade, Division
from django.db import transaction

from apps.accounts.utils import user_name_creator

class CustomTokenObtainPairSerializer(TokenObtainPairSerializer):
    def validate(self, attrs):
        data = super().validate(attrs)
        user = self.user
        data['user_id'] = user.UserId
        if hasattr(self.user, 'details') and self.user.details:
            data['role'] = self.user.details.UserType
        else:
            data['role'] = None
        return data
        return data
    
class GradeSerializer(serializers.ModelSerializer):
    class Meta:
        model = Grade
        fields = '__all__'

class DivisionSerializer(serializers.ModelSerializer):
    class Meta:
        model = Division
        fields = '__all__'

class TeacherCreateSerializer(serializers.ModelSerializer):
    # Fields for creating the related User record
    email = serializers.EmailField(write_only=True)
    password = serializers.CharField(
        write_only=True, style={'input_type': 'password'}
    )
    first_name = serializers.CharField(write_only=True)
    last_name = serializers.CharField(write_only=True)
    gender = serializers.ChoiceField(choices=UserDetails.GENDER_CHOICES, write_only=True)
    profile_pic = serializers.ImageField(required=False, allow_null=True)
    
    # Teacher-specific many-to-many fields (if these exist on UserDetails)
    assigned_grades = serializers.PrimaryKeyRelatedField(
        queryset=Grade.objects.all(), many=True, required=False
    )
    assigned_divisions = serializers.PrimaryKeyRelatedField(
        queryset=Division.objects.all(), many=True, required=False
    )
    
    class Meta:
        # We return the UserDetails instance as the created object.
        model = UserDetails
        fields = [
            "assigned_grades",
            "assigned_divisions",
            "email",
            "password",
            "first_name",
            "last_name",
            "gender",
            'profile_pic'
        ]
    
    def create(self, validated_data):
        try:
            # Extract basic user fields.
            email = validated_data.pop("email")
            password = validated_data.pop("password")
            first_name = validated_data.pop("first_name")
            last_name = validated_data.pop("last_name")
            gender = validated_data.pop("gender")
            
            # Pop teacher-specific many-to-many fields.
            assigned_grades = validated_data.pop("assigned_grades", None)
            assigned_divisions = validated_data.pop("assigned_divisions", None)
            profile_pic = validated_data.pop("profile_pic", None)
            
            with transaction.atomic():
                if User.objects.filter(Email=email).exists():
                    raise serializers.ValidationError({"error": "A user with this email already exists."})
                # Create the user in the User table. Pass user_type as 'teacher' to the manager.
                user = User.objects.create_user(
                    UserName=None,  # auto-generated by the custom manager
                    Email=email,
                    password=password,
                    InstitutionId=1
                )
                
                # Create the corresponding UserDetails record.
                details = UserDetails.objects.create(
                    user=user,
                    FirstName=first_name,
                    LastName=last_name,
                    Gender=gender,
                    UserType='Teacher',
                    profile_pic=profile_pic
                    # Other fields can be populated as needed.
                )
                user_name=user_name_creator('Teacher', user)
                user.UserName=user_name
                user.save()
                
                # If your UserDetails model includes many-to-many relationships, assign them.
                if assigned_grades is not None:
                    details.assigned_grades.set(assigned_grades)
                if assigned_divisions is not None:
                    details.assigned_divisions.set(assigned_divisions)
            
            return details
        except Exception as e:
            raise serializers.ValidationError({"error": str(e)})
    
class TeacherListSerializer(serializers.ModelSerializer):
    full_name = serializers.SerializerMethodField()
    UserName = serializers.CharField(source="user.UserName", read_only=True)
    email = serializers.CharField(source="user.Email", read_only=True)
    gender = serializers.CharField(source="user.gender", read_only=True)
    UserId = serializers.CharField(source="user.UserId", read_only=True)
    userType = serializers.CharField(source="UserType", read_only=True)
    IsActive = serializers.CharField(source="user.IsActive", read_only=True)

    class Meta:
        model = UserDetails
        fields = ['full_name', 'email', 'UserId', 'UserName', 'gender', 'userType','IsActive']

    def get_full_name(self, obj):
        first = obj.FirstName or ""
        last = obj.LastName or ""
        return f"{first} {last}".strip()
    
class TeacherDetailSerializer(serializers.ModelSerializer):
    # Fields from the related User model
    FirstName = serializers.CharField( required=True)
    LastName = serializers.CharField( required=True)
    Gender = serializers.CharField( required=True)
    email = serializers.CharField(source="user.Email", read_only=True)
    UserId = serializers.CharField(source="user.UserId", read_only=True)
    IsActive = serializers.BooleanField(source="user.IsActive", read_only=True)

    # Explicitly declare ManyToMany relationships
    assigned_grades = serializers.PrimaryKeyRelatedField(
        queryset=Grade.objects.all(), many=True, required=False
    )
    assigned_divisions = serializers.PrimaryKeyRelatedField(
        queryset=Division.objects.all(), many=True, required=False
    )
    
    class Meta:
        model = UserDetails
        fields = [
            "UserId",               # Teacher's primary key (UserId from related user)
            "FirstName",            # Updatable user first name
            "LastName",        # Updatable user last name
            "email",           # Updatable user gender
            "Gender",  # Updatable user phone number
            "IsActive",
            "assigned_grades",
            "assigned_divisions",
        ]
    
    def get_full_name(self, obj):
        first = obj.FirstName or ""
        last = obj.LastName or ""
        return f"{first} {last}".strip()

    def update(self, instance, validated_data):
        # Extract and update nested user data.
        user_data = validated_data.pop("user", {})
        user = instance.user
        for attr, value in user_data.items():
            if attr == "UserName":
                continue
            setattr(user, attr, value)
        user.save()
        # Extract many-to-many fields separately.
        assigned_grades = validated_data.pop("assigned_grades", None)
        assigned_divisions = validated_data.pop("assigned_divisions", None)
        
        # Update the remaining fields on UserDetails.
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        
        # Update many-to-many relationships if provided.
        if assigned_grades is not None:
            instance.assigned_grades.set(assigned_grades)
        if assigned_divisions is not None:
            instance.assigned_divisions.set(assigned_divisions)
        
        return instance
    
class StudentCreateSerializer(serializers.ModelSerializer):
    email = serializers.EmailField(write_only=True)
    # password = serializers.CharField(write_only=True, style={'input_type': 'password'}, required=False)
    first_name = serializers.CharField(write_only=True)
    last_name = serializers.CharField(write_only=True)
    gender = serializers.ChoiceField(choices=UserDetails.GENDER_CHOICES, write_only=True)

    # Correct field names to match UserDetails model
    GradeId = serializers.PrimaryKeyRelatedField(queryset=Grade.objects.all(), required=True)
    DivisionId = serializers.PrimaryKeyRelatedField(queryset=Division.objects.all(), required=True)
    profile_pic = serializers.ImageField(required=False, allow_null=True)

    class Meta:
        model = UserDetails
        fields = [
            "date_of_birth",
            "GradeId",      # Correct field name from 'grade' to 'GradeId'
            "DivisionId",   # Correct field name from 'division' to 'DivisionId'
            "AdmissionNo",
            "email",
            # "password",
            "first_name",
            "last_name",
            "gender",
            "profile_pic",
        ]

    def create(self, validated_data):
        email = validated_data.get("email")
        # password = validated_data.get("password")
        first_name = validated_data.get("first_name")
        last_name = validated_data.get("last_name")
        gender = validated_data.get("gender")
        GradeId = validated_data.get("GradeId")  # Use correct field name
        DivisionId = validated_data.get("DivisionId")  # Use correct field name
        date_of_birth = validated_data.get("date_of_birth")
        admission_number = validated_data.get("AdmissionNo")
        profile_pic = validated_data.pop("profile_pic", None)

        with transaction.atomic():
            if User.objects.filter(Email=email).exists():
                raise serializers.ValidationError({"error": "A user with this email already exists."})
            # Create the User record with role 'student'
            user = User.objects.create_user(
                UserName=None,  # auto-generated by the custom manager
                Email=email,
                password="student@123",
                InstitutionId=1
            )

            # Create the Student record linking to the user.
            student = UserDetails.objects.create(
                user=user,
                FirstName=first_name,
                LastName=last_name,
                Gender=gender,
                date_of_birth=date_of_birth,
                GradeId=GradeId,
                DivisionId=DivisionId,
                AdmissionNo=admission_number,
                UserType='Learner',
                IsActive=True,
                profile_pic=profile_pic
            )
            user_name = user_name_creator('Learner', user)
            user.UserName = user_name
            user.save()

        return student
    
class StudentListSerializer(serializers.ModelSerializer):
    UserId = serializers.CharField(source="user.UserId", read_only=True)
    full_name = serializers.SerializerMethodField()
    UserName = serializers.CharField(source="user.UserName", read_only=True)
    email = serializers.CharField(source="user.Email", read_only=True)
    IsActive = serializers.CharField(source="user.IsActive", read_only=True)

    class Meta:
        model = UserDetails
        fields = ['full_name', 'email','UserId', 'UserName', 'Gender', 'IsActive','GradeId','DivisionId','UserType']

    def get_full_name(self, obj):
        # Combine first and last names; adjust as needed.
        first = obj.FirstName or ""
        last = obj.LastName or ""
        return f"{first} {last}".strip()

class StudentDetailSerializer(serializers.ModelSerializer):
    # Nested user fields (read-only username)
    UserId = serializers.CharField(source="user.UserId", read_only=True)
    FirstName = serializers.CharField(required=False)
    LastName = serializers.CharField(required=False)
    Gender = serializers.CharField(required=True)
    Email = serializers.EmailField(source="user.Email", required=False)
    PhoneNumber = serializers.CharField(source="user.PhoneNumber", required=False)
    IsActive = serializers.BooleanField(source="user.IsActive", read_only=True)

    # Correct field names to match UserDetails model
    GradeId = serializers.PrimaryKeyRelatedField(queryset=Grade.objects.all(), required=True)
    DivisionId = serializers.PrimaryKeyRelatedField(queryset=Division.objects.all(), required=True)
    
    class Meta:
        model = UserDetails
        fields = [
            "UserId",                # Student's primary key
            "FirstName",         # Updatable user first name
            "LastName",          # Updatable user last name
            "Gender",            # Updatable user gender
            "Email",             # Updatable user email
            "PhoneNumber",       # Updatable user phone number
            "date_of_birth",
            "GradeId",
            "DivisionId",
            "AdmissionNo",
            "IsActive"          # Student's active status
        ]
    
    def update(self, instance, validated_data):
        # Extract nested user data if provided.
        user_data = validated_data.pop("user", {})
        user = instance.user
        for attr, value in user_data.items():
            # Skip updating the username even if provided.
            if attr == "UserName":
                continue
            setattr(user, attr, value)
        user.save()
        
        # Update Student-specific fields.
        for attr, value in validated_data.items():
            setattr(instance, attr, value)
        instance.save()
        return instance
